"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Download, FileText, Code, Database, CheckCircle, Loader2 } from "lucide-react"
import type { SystemPreset } from "./system-presets"

interface ArtifactsGenerationProps {
  sourcePreset: SystemPreset
  targetPreset: SystemPreset
  sourceConfig: Record<string, string>
  targetConfig: Record<string, string>
  fieldMapping: Array<{ source: string; target: string; transform?: string }>
  schedule: { frequency: string; cron: string }
  loadMode: string
}

interface GeneratedArtifact {
  name: string
  type: "sql" | "python" | "yaml" | "json"
  content: string
  description: string
}

export function ArtifactsGeneration({
  sourcePreset,
  targetPreset,
  sourceConfig,
  targetConfig,
  fieldMapping,
  schedule,
  loadMode,
}: ArtifactsGenerationProps) {
  const [artifacts, setArtifacts] = useState<GeneratedArtifact[]>([])
  const [isGenerating, setIsGenerating] = useState(false)
  const [selectedArtifact, setSelectedArtifact] = useState<GeneratedArtifact>()

  useEffect(() => {
    generateArtifacts()
  }, [])

  const generateArtifacts = async () => {
    setIsGenerating(true)

    try {
      const response = await fetch("/api/generate/artifacts", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          sourcePreset,
          targetPreset,
          sourceConfig,
          targetConfig,
          fieldMapping,
          schedule,
          loadMode,
        }),
      })

      if (!response.ok) {
        throw new Error("Failed to generate artifacts")
      }

      const data = await response.json()
      setArtifacts(data.artifacts)
      if (data.artifacts.length > 0) {
        setSelectedArtifact(data.artifacts[0])
      }
    } catch (error) {
      console.error("Error generating artifacts:", error)
      // Fallback to mock artifacts for demo
      generateMockArtifacts()
    } finally {
      setIsGenerating(false)
    }
  }

  const generateMockArtifacts = () => {
    const mockArtifacts: GeneratedArtifact[] = [
      {
        name: "pipeline_config.yaml",
        type: "yaml",
        description: "Конфигурация пайплайна для Airflow",
        content: `# Data Pipeline Configuration
source:
  type: ${sourcePreset.id}
  config:
${Object.entries(sourceConfig)
  .map(([key, value]) => `    ${key}: "${value}"`)
  .join("\n")}

target:
  type: ${targetPreset.id}
  config:
${Object.entries(targetConfig)
  .map(([key, value]) => `    ${key}: "${value}"`)
  .join("\n")}

schedule:
  frequency: ${schedule.frequency}
  cron: "${schedule.cron}"
  
load_mode: ${loadMode}

field_mapping:
${fieldMapping
  .map(
    (mapping) => `  - source: ${mapping.source}
    target: ${mapping.target}${
      mapping.transform
        ? `
    transform: ${mapping.transform}`
        : ""
    }`,
  )
  .join("\n")}`,
      },
      {
        name: "extract_transform_load.py",
        type: "python",
        description: "Python скрипт для ETL процесса",
        content: `#!/usr/bin/env python3
"""
Data Pipeline ETL Script
Generated by AI Data Engineer
"""

import pandas as pd
from datetime import datetime
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class DataPipeline:
    def __init__(self):
        self.source_config = ${JSON.stringify(sourceConfig, null, 8)}
        self.target_config = ${JSON.stringify(targetConfig, null, 8)}
        
    def extract(self):
        """Extract data from ${sourcePreset.name}"""
        logger.info("Starting data extraction from ${sourcePreset.name}")
        # TODO: Implement ${sourcePreset.name} connection and data extraction
        pass
        
    def transform(self, data):
        """Transform data according to field mapping"""
        logger.info("Starting data transformation")
        # Field mapping transformations
${fieldMapping.map((mapping) => `        # ${mapping.source} -> ${mapping.target}${mapping.transform ? ` (${mapping.transform})` : ""}`).join("\n")}
        return data
        
    def load(self, data):
        """Load data to ${targetPreset.name}"""
        logger.info("Starting data load to ${targetPreset.name}")
        # TODO: Implement ${targetPreset.name} connection and data loading
        pass
        
    def run(self):
        """Execute the complete ETL pipeline"""
        try:
            data = self.extract()
            transformed_data = self.transform(data)
            self.load(transformed_data)
            logger.info("Pipeline completed successfully")
        except Exception as e:
            logger.error(f"Pipeline failed: {str(e)}")
            raise

if __name__ == "__main__":
    pipeline = DataPipeline()
    pipeline.run()`,
      },
      {
        name: "airflow_dag.py",
        type: "python",
        description: "Airflow DAG для автоматизации пайплайна",
        content: `from airflow import DAG
from airflow.operators.python import PythonOperator
from datetime import datetime, timedelta

default_args = {
    'owner': 'data-engineer',
    'depends_on_past': False,
    'start_date': datetime(2024, 1, 1),
    'email_on_failure': False,
    'email_on_retry': False,
    'retries': 1,
    'retry_delay': timedelta(minutes=5),
}

dag = DAG(
    '${sourcePreset.id}_to_${targetPreset.id}_pipeline',
    default_args=default_args,
    description='Data pipeline from ${sourcePreset.name} to ${targetPreset.name}',
    schedule_interval='${schedule.cron}',
    catchup=False,
)

def extract_task():
    # Extract from ${sourcePreset.name}
    pass

def transform_task():
    # Transform data
    pass

def load_task():
    # Load to ${targetPreset.name}
    pass

extract = PythonOperator(
    task_id='extract_data',
    python_callable=extract_task,
    dag=dag,
)

transform = PythonOperator(
    task_id='transform_data',
    python_callable=transform_task,
    dag=dag,
)

load = PythonOperator(
    task_id='load_data',
    python_callable=load_task,
    dag=dag,
)

extract >> transform >> load`,
      },
    ]

    setArtifacts(mockArtifacts)
    setSelectedArtifact(mockArtifacts[0])
  }

  const downloadArtifact = (artifact: GeneratedArtifact) => {
    const blob = new Blob([artifact.content], { type: "text/plain" })
    const url = URL.createObjectURL(blob)
    const a = document.createElement("a")
    a.href = url
    a.download = artifact.name
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
    URL.revokeObjectURL(url)
  }

  const downloadAllArtifacts = () => {
    artifacts.forEach((artifact) => {
      setTimeout(() => downloadArtifact(artifact), 100)
    })
  }

  const getFileIcon = (type: string) => {
    switch (type) {
      case "python":
        return <Code className="w-4 h-4" />
      case "sql":
        return <Database className="w-4 h-4" />
      default:
        return <FileText className="w-4 h-4" />
    }
  }

  if (isGenerating) {
    return (
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-12">
          <Loader2 className="w-8 h-8 animate-spin mb-4" />
          <h3 className="text-lg font-semibold mb-2">Генерация артефактов...</h3>
          <p className="text-muted-foreground text-center">
            Создаем конфигурационные файлы и скрипты для вашего пайплайна
          </p>
        </CardContent>
      </Card>
    )
  }

  return (
    <div className="space-y-6">
      {/* Summary */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <div>
              <CardTitle className="flex items-center space-x-2">
                <CheckCircle className="w-5 h-5 text-green-500" />
                <span>Артефакты сгенерированы</span>
              </CardTitle>
              <CardDescription>
                Создано {artifacts.length} файлов для пайплайна {sourcePreset.name} → {targetPreset.name}
              </CardDescription>
            </div>
            <Button onClick={downloadAllArtifacts} className="flex items-center space-x-2">
              <Download className="w-4 h-4" />
              <span>Скачать все</span>
            </Button>
          </div>
        </CardHeader>
      </Card>

      {/* Artifacts List and Preview */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Artifacts List */}
        <Card>
          <CardHeader>
            <CardTitle>Файлы проекта</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-2">
              {artifacts.map((artifact, index) => (
                <div
                  key={index}
                  className={`p-3 rounded-lg border cursor-pointer transition-colors ${
                    selectedArtifact?.name === artifact.name
                      ? "border-primary bg-primary/5"
                      : "border-border hover:bg-muted/50"
                  }`}
                  onClick={() => setSelectedArtifact(artifact)}
                >
                  <div className="flex items-center justify-between">
                    <div className="flex items-center space-x-2">
                      {getFileIcon(artifact.type)}
                      <div>
                        <div className="font-medium text-sm">{artifact.name}</div>
                        <div className="text-xs text-muted-foreground">{artifact.description}</div>
                      </div>
                    </div>
                    <Button
                      size="sm"
                      variant="ghost"
                      onClick={(e) => {
                        e.stopPropagation()
                        downloadArtifact(artifact)
                      }}
                    >
                      <Download className="w-3 h-3" />
                    </Button>
                  </div>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>

        {/* File Preview */}
        <Card className="lg:col-span-2">
          <CardHeader>
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-2">
                {selectedArtifact && getFileIcon(selectedArtifact.type)}
                <CardTitle>{selectedArtifact?.name || "Выберите файл"}</CardTitle>
                <Badge variant="outline">{selectedArtifact?.type.toUpperCase()}</Badge>
              </div>
              {selectedArtifact && (
                <Button
                  size="sm"
                  onClick={() => downloadArtifact(selectedArtifact)}
                  className="flex items-center space-x-1"
                >
                  <Download className="w-3 h-3" />
                  <span>Скачать</span>
                </Button>
              )}
            </div>
            {selectedArtifact && <CardDescription>{selectedArtifact.description}</CardDescription>}
          </CardHeader>
          <CardContent>
            {selectedArtifact ? (
              <ScrollArea className="h-96 w-full rounded-md border">
                <pre className="p-4 text-sm">
                  <code>{selectedArtifact.content}</code>
                </pre>
              </ScrollArea>
            ) : (
              <div className="h-96 flex items-center justify-center text-muted-foreground">
                Выберите файл для предварительного просмотра
              </div>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  )
}
